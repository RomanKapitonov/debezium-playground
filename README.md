# Running with docker locally
```
docker-compose up
```

## Database setup
#### Connect to the database
```shell
mysql --host=0.0.0.0 --user=debezium --password=dbz
```

```sql
GRANT ALL PRIVILEGES ON *.* TO 'debezium'@'%';

CREATE TABLE users (
  id INT AUTO_INCREMENT PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  email VARCHAR(255) UNIQUE NOT NULL
);
```

## Debezium connector commands:

#### Register a connector
```shell
curl -i -X POST -H "Accept:application/json" -H "Content-Type:application/json" http://localhost:8083/connectors/ -d @debezium-connector-config/mysql-connector.json
```

#### Remove a connector
```shell
curl -X DELETE http://localhost:8083/connectors/mysql-connector
```

## Run a console consumer
```shell
docker-compose exec kafka /kafka/bin/kafka-console-consumer.sh --bootstrap-server kafka:9092 --topic dbserver1.test_db.users --from-beginning
```

## Set the max message size to enforce worker failure
```shell
docker-compose exec kafka /kafka/bin/kafka-configs.sh --bootstrap-server kafka:9092 --alter --entity-type topics --entity-name dbserver1.test_db.users --add-config max.message.bytes=100
```

## Push data to stream

```sql
INSERT INTO users (name, email)
VALUES (CONCAT('User', ROUND(RAND() * 100)), CONCAT('user', ROUND(RAND() * 100), '@example.com'));
```

## Observe the failed worker status
```shell
curl -X GET http://0.0.0.0:8083/connectors/mysql-connector/status
```

# Setting up kubernetes deployment with ArgoCD locally

### Install Argo CD CLI:

Follow the instructions for your operating system: https://argo-cd.readthedocs.io/en/stable/cli_installation/

### Deploy Argo CD on your local Kubernetes cluster:

```shell
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
```
This will deploy Argo CD components into the argocd namespace.

### Expose Argo CD server using Minikube tunnel:

By default, the Argo CD server is not exposed externally. You can access it by creating a Minikube tunnel:

```shell
minikube service -n argocd argocd-server --url
```
This command will output the URL to access the Argo CD server. Keep the terminal open as closing it will also close the tunnel.

### Get the Argo CD initial password:

The initial password for the admin user is autogenerated and stored as the argocd-initial-admin-secret secret in the argocd namespace.

```shell
kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 --decode
```

### Log in to Argo CD using the CLI:

Replace <argo-cd-server-url> with the URL you got minikube tunnel:

```shell
argocd login <argo-cd-server-url> --username admin --password <your-initial-password>
```

### Create a new Argo CD application:

First, you need to store your Kubernetes resource files in a Git repository. Argo CD will use this repository to deploy and sync your application.

Create a new Git repository (GitHub, GitLab, Bitbucket, etc.) and push your Kubernetes resource files (e.g., deployment.yaml, service.yaml) to it.

### Create ArgoCD namespace

```shell
kubectl create namespace debezium-playground
```

### Now, create a new Argo CD application:

```shell
argocd app create debezium-playground \
  --repo https://github.com/RomanKapitonov/debezium-playground.git \
  --path ./k8s-manifests \
  --dest-server https://kubernetes.default.svc \
  --dest-namespace debezium-playground \
  --sync-policy automated
```

### Check the status of your application:

```shell
argocd app get debezium-playground
```
This will display the current status of your application, including whether it's synced or out-of-sync.

### Access Argo CD Web UI:

Open the Argo CD server URL you got in step 3 in your web browser. Log in with the admin user and the initial password you got in step 4.
